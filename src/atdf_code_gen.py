#!/usr/bin/python3

# Using the pack: http://packs.download.atmel.com/Atmel.SAMD51_DFP.1.2.139.atpack

# This script can be used to generate code from an atdf file:
# - peripheral IDs for the GCLK device
# - GPIO functions
# - Device package with peripheral instances
# - Main_Clock on/off procedures for peripherals
# - Interrupt Names

import sys
import pathlib
import os
import json
from xml.dom.minidom import parse, parseString

def mkdirs(path):
    pathlib.Path(path).mkdir(parents=True, exist_ok=True)


def find_parent_instance(node):
    while True:
        node = node.parentNode
        name = node.tagName
        if name == "avr-tools-device-file":
            return ""
        if name == "instance":
            return node.getAttribute('name')


def write_file(path, content):
    with open(path, 'w') as filetowrite:
        filetowrite.write(content)


def get_param(dom, param_name):
    for param in dom.getElementsByTagName('param'):
        if param.getAttribute('name') == param_name:
            return param.getAttribute('value')

    return None


def gen_port(instance, offset):
    group_offset = 0

    spec = ""
    # Find how many port groups are on the device (A, B, C, etc.)
    groups = set()
    for signal in instance.getElementsByTagName('signal'):
        pad = signal.getAttribute('pad')
        groups.add(pad[1])
    groups = list(groups)
    groups.sort()

    # Create a instance for each group
    for grp in groups:
        spec += "   -- PORT%s --\n\n" % grp
        spec += "   PORT%s_Internal : aliased Port_Internal\n" % grp
        spec += "     with Import, Address => System'To_Address (%s + 16#%.3x#);\n" % (offset, group_offset)
        spec += "   PORT%s : aliased Port_Controller (PORT%s_Internal'Access);\n\n" % (grp, grp)

        for pin in range(32):
            spec += "   P{1}{0:02d} : aliased GPIO_Point (PORT{1}'Access, {0});\n".format(int(pin), grp)

        group_offset += 0x80
        spec += "\n"

    return spec


def gen_GCLK_ID(dom, dir):

    spec = "--  Generated by a script from an \"avr tools device file\" (atdf)\n"
    spec += "package SAM.Clock_Generator.IDs is\n"

    for param in dom.getElementsByTagName('param'):
        name = param.getAttribute('name')
        if name.startswith('GCLK_ID'):
            value = param.getAttribute('value')
            instance = find_parent_instance(param)

            # Remove the GCLK_ID prefix from the name
            name = name[8:]

            if instance != "" and name != "":
                identifier = instance + "_" + name
            else:
                identifier = instance + name


            spec += "   %-20s : constant Peripheral_Id := %s;\n" % (identifier, value)

    spec += "end SAM.Clock_Generator.IDs;\n"


    write_file(os.path.join(dir, "sam-clock_generator-ids.ads"), spec)


def gen_MCLK(dom, dir):

    spec = ""
    spec += "--  Generated by a script from an \"avr tools device file\" (atdf)\n"
    spec += "package SAM.Main_Clock is\n"

    body = ""
    body += "--  Generated by a script from an \"avr tools device file\" (atdf)\n"
    body += "with HAL; use HAL;\n"
    body += "with System;\n"
    body += "package body SAM.Main_Clock is\n"

    # Find the base address of the registers
    for register_group in dom.getElementsByTagName('register-group'):
        if register_group.getAttribute('name-in-module') in ['MCLK']:
            base_address = register_group.getAttribute('offset')

            # Convert to Ada literal
            base_address = "16#" + base_address[2:] + "#"

            body += "   Base_Address : constant := " + base_address +";\n"

    peripherals = {}

    # Find all MASK registers and their offsets
    for module in dom.getElementsByTagName('module'):
        if module.getAttribute('name') in ['MCLK', 'PM']:
            for register in module.getElementsByTagName('register'):
                if register.getAttribute('name').endswith('MASK'):
                    regoffset = register.getAttribute('offset')
                    regsize = register.getAttribute('size')
                    regname = register.getAttribute('name')

                    # Convert to Ada literal
                    regoffset = "16#" + regoffset[2:] + "#"

                    if regsize != '4':
                        print("32bit register exptected...")
                        sys.exit(1)

                    body += "\n   %s : UInt32\n" % regname
                    body += "     with Volatile,\n"
                    body += "          Address => System'To_Address (Base_Address + %s);\n" % regoffset

                    # Find all the masks for each peripheral. Some peripherals
                    # have clock both in AHB and APB domains.
                    for bitfield in register.getElementsByTagName('bitfield'):
                            name = bitfield.getAttribute('name')
                            mask = bitfield.getAttribute('mask')

                            # Remove trailing '_'
                            name = name[:-1]

                            # Convert to Ada literal
                            mask = "16#" + mask[2:] + "#"

                            mask_info = {'regname': regname, 'mask': mask}
                            if name in peripherals:
                                peripherals[name].append(mask_info)
                            else:
                                peripherals[name] = [mask_info]


    # Generate On and Off procedures for each peripherals
    for name in peripherals:
        masks = peripherals[name]

        spec += "\n   -- %s --\n" % name
        spec += "   procedure %s_On with Inline;\n" % name
        spec += "   procedure %s_Off with Inline;\n" % name

        body += "\n   -- %s --\n\n" % name
        body += "   procedure %s_On is\n" % name
        body += "   begin\n"
        for m in masks:
            body += "      %s := %s or %s;\n" % (m['regname'], m['regname'], m['mask'])
        body += "   end %s_On;\n\n" % name

        body += "   procedure %s_Off is\n" % name
        body += "   begin\n"
        for m in masks:
            body += "      %s := %s and not %s;\n" % (m['regname'], m['regname'], m['mask'])
        body += "   end %s_Off;\n" % name

    spec += "end SAM.Main_Clock;\n"
    body += "end SAM.Main_Clock;\n"

    write_file(os.path.join(dir, "sam-main_clock.ads"), spec)
    write_file(os.path.join(dir, "sam-main_clock.adb"), body)


def gen_device(dom, dir):

    dependencies = []
    driver_dependencies = [];

    spec = "\n"
    spec += "--  Generated by a script from an \"avr tools device file\" (atdf)\n"
    spec += "package SAM.Device is\n\n"


    for register_group in dom.getElementsByTagName('register-group'):
        device = register_group.getAttribute('name-in-module')
        offset = register_group.getAttribute('offset')
        name   = register_group.getAttribute('name')

        # Convert to Ada literal
        offset = "16#" + offset[2:] + "#"

        if device == "SERCOM":
            number = name[6:]

            dependencies.append("System")
            dependencies.append("SAM.SERCOM")
            dependencies.append("SAM.SERCOM.SPI")
            dependencies.append("SAM.SERCOM.I2C")

            driver_dependencies.append("sercom_u2201")

            spec += "   -- %s --\n\n" % name
            spec += "   %s_Internal : aliased SAM.SERCOM.SERCOM_Internal\n" % name
            spec += "     with Import, Address => System'To_Address (%s);\n\n" % offset
            spec += "   SPI%s : aliased SAM.SERCOM.SPI.SPI_Device (%s_Internal'Access);\n" % (number, name)
            spec += "   I2C%s : aliased SAM.SERCOM.I2C.I2C_Device (%s_Internal'Access);\n" % (number, name)
            spec += "\n"

        elif device == "PORT":

            if name == "PORT_IOBUS":
                continue

            spec += gen_port(register_group.parentNode, offset)

            dependencies.append("System")
            dependencies.append("SAM.Port")
            driver_dependencies.append("port_u2210")

        elif device == "GCLK":
            driver_dependencies.append("gclk_u2122")

        elif device == "DMAC":
            driver_dependencies.append("dmac_u2503")

        elif device == "DAC":
            driver_dependencies.append("dac_u2502")

        elif device == "OSCCTRL":
            driver_dependencies.append("oscctrl_u2401")

        elif device == "QSPI":
            driver_dependencies.append("qspi_u2008")

        elif device == "EIC":
            driver_dependencies.append("eic_u2254")

        elif device == "ADC":
            driver_dependencies.append("adc_u2500")

            number = name[3:]

            dependencies.append("System")
            dependencies.append("SAM.ADC")

            spec += "   -- %s --\n\n" % name
            spec += "   %s_Internal : aliased SAM.ADC.ADC_Internal\n" % name
            spec += "     with Import, Address => System'To_Address (%s);\n\n" % offset
            spec += "   ADC%s : aliased SAM.ADC.ADC_Device (%s_Internal'Access);\n" % (number, name)
            spec += "\n"

        elif device == "TC":
            driver_dependencies.append("tc_u2249")

            number = name[2:]
            if int(number) % 2 == 0:
                master = "True"
            else:
                master = "False"

            dependencies.append("System")
            dependencies.append("SAM.TC")

            spec += "   -- %s --\n\n" % name
            spec += "   %s_Internal : aliased SAM.TC.TC_Internal\n" % name
            spec += "     with Import, Address => System'To_Address (%s);\n\n" % offset
            spec += "   TC%s : aliased SAM.TC.TC_Device (%s_Internal'Access, Master => %s);\n" % (number, name, master)
            spec += "\n"

    spec += "end SAM.Device;\n"

    # Remove duplicates dependencies
    dependencies = list(set(dependencies))
    dependencies.sort()
    driver_dependencies = list(set(driver_dependencies))
    driver_dependencies.sort()

    for dep in dependencies:
        spec = ("with %s; use %s;\n" % (dep, dep)) + spec

    write_file(os.path.join(dir, "sam-device.ads"), spec)

    return driver_dependencies


def gen_functions(dom, dir):

    spec = "\n"
    spec += "--  Generated by a script from an \"avr tools device file\" (atdf)\n\n"
    spec += "with SAM.Port; use SAM.Port;\n\n"
    spec += "package SAM.Functions is\n\n"

    for signal in dom.getElementsByTagName('signal'):
        group = signal.getAttribute('group')
        index = signal.getAttribute('index')
        pad = signal.getAttribute('pad')
        function = signal.getAttribute('function')

        if function == "default":
            continue

        # Function are supposed to be only one letter, sometime there is a
        # sufix in the atdf. Only keep the first letter of the function.
        function = function[0]

        if function < 'A' or function > 'N':
            continue

        instance = signal.parentNode.parentNode
        instance_name = instance.getAttribute('name')
        spec += "   %-25s : constant Peripheral_Function := %s;\n" % \
              (pad + "_" + instance_name + "_" + group + index, function)

    spec += "end SAM.Functions;\n"
    write_file(os.path.join(dir, "sam-functions.ads"), spec)


def gen_interrupts(svd_file, dir):
    dom = parse(svd_file)

    interrupts = {}
    last_int = 0
    for interrupt in dom.getElementsByTagName('interrupt'):
        name = interrupt.getElementsByTagName('name')[0].firstChild.nodeValue

        name = name.replace('_INTREQ', '') + "_interrupt"
        name = name.lower()
        index = int(interrupt.getElementsByTagName('value')[0].firstChild.nodeValue)

        if index >= 0:
            interrupts[name] = index
            if index > last_int:
                last_int = index

    spec = "\n"
    spec += "--  Generated by a script from an \"avr tools device file\" (atdf)\n\n"
    spec += "package SAM.Interrupt_Names is\n\n"
    spec += "   Number_Of_Interrupts : constant := %d;\n\n" % (last_int + 1)
    for interrupt in interrupts:
        spec += "   %-30s : constant := %d;\n" % (interrupt, interrupts[interrupt])
    spec += "end SAM.Interrupt_Names;\n"
    write_file(os.path.join(dir, "sam-interrupt_names.ads"), spec)

    return (interrupts)


def gen_device_info(dom, dir, driver_dependencies, interrupts):
    device = dom.getElementsByTagName('device')[0]
    name = device.getAttribute('name')
    architecture = device.getAttribute('architecture')
    FPU = int(get_param(dom, '__FPU_PRESENT')) != 0
    MPU = int(get_param(dom, '__MPU_PRESENT')) != 0

    info = {}
    info['name'] = name
    info['architecture'] = architecture
    info['has_FPU'] = FPU
    info['has_MPU'] = MPU
    info['drivers'] = driver_dependencies
    info['memories'] = {}

    info['interrupts'] = {}
    nbr_of_ints = 0
    for name in interrupts:
        if interrupts[name] + 1 > nbr_of_ints:
            nbr_of_ints = interrupts[name] + 1

        info['interrupts'][interrupts[name]] = name
    info['number_of_interrupts'] = nbr_of_ints

    boot_mem = ""
    boot_size = 0

    for memory in dom.getElementsByTagName('memory-segment'):
        name = memory.getAttribute('name')
        kind = memory.getAttribute('type')
        start = memory.getAttribute('start')
        size = memory.getAttribute('size')

        # Discard CoreSight ETB segments
        if name.endswith("_ETB") or name.endswith("_RET1"):
            continue

        if kind == "flash":
            kind = "rom"

        if kind in ['ram', 'rom']:
            info['memories'][name] = {'kind': kind, 'start': start, 'size': size}

            # Find the boot mem by taking the biggest segment
            if int(size, 16) > boot_size:
                boot_size = int(size, 16)
                boot_mem = name


    info['boot_mem'] = boot_mem

    write_file(os.path.join(dir, "device_info.json"), json.dumps(info, indent=2))

    return info


def gen_project_file(info):
    name = info['name']

    gpr = ''

    gpr += 'with "hal.gpr";\n'
    gpr += 'with "cortex_m4f.gpr";\n'
    gpr += 'with "samd51_hal_common.gpr";\n'
    gpr += '\n'
    gpr += 'project %s is\n' % name
    gpr += '\n'
    gpr += '   for Source_Dirs use ("src",\n'
    gpr += '                        "src/drivers/**",\n'
    gpr += '                        "src/devices/SAMD51/%s");\n' % name
    gpr += '\n'
    gpr += '   for Object_Dir use "obj/%s";\n' % name
    gpr += '\n'
    gpr += '   for Target use "arm-eabi";\n'
    gpr += '   for Runtime ("Ada") use "zfp-cortex-m4f";\n'
    gpr += '\n'
    gpr += '   package Compiler renames Samd51_Hal_Common.Compiler;\n'
    gpr += '\n'
    gpr += '   package Device_Configuration is\n'
    gpr += '      for CPU_Name use "ARM Cortex-M4F";\n'
    gpr += '      for Number_Of_Interrupts use "%d";\n' % info['number_of_interrupts']
    gpr += '\n'
    gpr += '      for Memories use ("%s");\n' % ('", "'.join(info['memories']))
    gpr += '      for Boot_Memory use "%s";\n' % info['boot_mem']
    gpr += '\n'

    for mem in info['memories']:
        gpr += '      for Mem_Kind ("%s") use "%s";\n' % (mem, info['memories'][mem]['kind'])
        gpr += '      for Address ("%s") use "%s";\n' % (mem, info['memories'][mem]['start'])
        gpr += '      for Size ("%s") use "%s";\n' % (mem, info['memories'][mem]['size'])
    gpr += '\n'
    for index in sorted(info['interrupts'].keys()):
        gpr += '      for Interrupt ("%d") use "%s";\n' % (index, info['interrupts'][index])
    gpr += '\n'
    gpr += '   end Device_Configuration;\n'
    gpr += '\n'
    gpr += 'end %s;\n' % name

    write_file(os.path.join('..', info['name'] + '.gpr'), gpr)


def gen_from_atdf(atdf):
    dom = parse(atdf)

    svd_file = os.path.join(os.path.dirname(atdf), '..', 'svd', os.path.basename(atdf)[:-5] + ".svd")

    device = dom.getElementsByTagName('device')[0]
    name = device.getAttribute('name')
    series = device.getAttribute('series')
    architecture = device.getAttribute('architecture')

    device_dir = os.path.join("devices", series, name)
    mkdirs(device_dir)

    gen_GCLK_ID(dom, device_dir)
    gen_MCLK(dom, device_dir)
    driver_dependencies = gen_device(dom, device_dir)
    gen_functions(dom, device_dir)
    interrupts = gen_interrupts(svd_file, device_dir)
    info = gen_device_info(dom, device_dir, driver_dependencies, interrupts)
    gen_project_file(info)

if ( __name__ == "__main__"):
    gen_from_atdf(sys.argv[1])
